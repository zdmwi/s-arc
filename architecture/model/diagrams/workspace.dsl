workspace {

    !identifiers hierarchical

    model {
        user = person "User"

        sArcSystem = softwareSystem "S-ARC System" {
            webApplication = container "Web Application" "Delivers the static content and the chat interface single page application" "Python and FastAPI" {
                user -> this "Visits chat.s-arc.com using" "[HTTPS]"
            }

            singlePageApplication = container "Single Page Application" "Provides a chat interface to interact with the LLM" "Typescript and React" {
                webApplication -> this "Delivers to the user's web browser"
                user -> this "Interacts with the LLM through a chat interface using" "[HTTPS]"
            }

            authenticationService = group "Authentication Service" {
                authenticationServiceApi = container "Authentication API" "Provides user authentication and authorization functionality" "Kotlin and Spring Boot" {
                    tags "Authentication Service" "Service API"
                    singlePageApplication -> this "Requests authentication and authorization tokens from" "[HTTPS]"
                }

                container "Authentication API Database" "Stores user information" "PostgreSQL" {
                    tags "Authentication Service" "Database"
                    authenticationServiceApi -> this "Reads from and writes to" "[TCP/SQL]"
                }
            }

            # This is a stateless service as well. It relies on the deploymed embedding model to return relevant embeddings.
            contextServiceApi = container "Context API" "Converts user prompts to vector embeddings and repackages the query for optimal response quality" "Python and FastAPI" {
                tags "Context Service" "Service API"
                singlePageApplication -> this "Sends natural language prompt to" "[HTTPS]"
            }

            # It's useful to have this as a separate service because this will need to be done for
            # each prompt that a user sends. This way, we can scale indepdently to maintain performance expectations.
            promptOptimizationService = group "Prompt Optimization Service" {
                promptOptimizationServiceApi = container "Prompt Optimization API" "Optimizes the provided prompt with relevant embeddings" "Python and FastAPI" {
                    tags "Prompt Optimization Service" "Service API"
                    contextServiceApi -> this "Forwards the prompt embeddings generated by the embedding model" "[HTTPS]"
                }

                container "Prompt Optimization API Database" "Performs a lookup " "Pinecone" {
                    tags "Prompt Optimization Service" "Database"
                    promptOptimizationServiceApi -> this "Reads from and writes to"
                }
            }

            llmService = group "LLM Service" {
                llmServiceApi = container "LLM API" "Serves as the interface to the fine-tuned LLM" "Python and FastAPI" {
                    tags "LLM Service" "Service API"
                    singlePageApplication -> this "Makes API calls to" "[HTTPS]"
                    this -> singlePageApplication "Streams the LLM response to" "[HTTPS]"
                }

                container "LLM API Database" "Stores the fine-tuned LLM model" "Pinecone"{
                    tags "LLM Service" "Database"
                    llmServiceApi -> this "Reads from and writes to"
                }

                container "LLM API Knowledge Graph" "Provides structured domain-specific knowledge for Software Architecture concepts" "Neo4j" {
                    tags "LLM Service" "Database"
                    llmServiceApi -> this "Reads from"
                }
            }

            # This is a stateless service so no database. It only exists to make API calls to the actual payment gateway.
            paymentProxyApi = container "Payment Proxy API" "Forwards payment processing requests to the payment system" "Python and FastAPI" {
                tags "Payment Proxy Service" "Service API
                singlePageApplication -> this "Makes API calls to" "[HTTPS]"
            }
        }

        paymentSystem = softwaresystem "Payment System" "Facilitates all payment processing functionalities" {
            tags "External System"
            sArcSystem.paymentProxyApi -> this "Sends payment processing requests for user subscriptions to" "[HTTPS]"
        }
    }

    views {
        systemContext sArcSystem {
            include *
        }

        container sArcSystem {
            include *
        }

        theme default

        styles {
            element "Person" {
                shape Person
            }
            element "Service API" {
                shape hexagon
            }
            element "Database" {
                shape cylinder
            }
        }
    }

    configuration {
        scope softwaresystem
    }
}